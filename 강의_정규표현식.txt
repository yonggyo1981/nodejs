정규표현식
	패턴으로 문자열을 찾거나, 변경
	
	RegExp 생성자
	new RegExp 
	
	/패턴/ -> 정규표현식 객체 생성
			
			.test(패턴을 체크할 문자열)
					- 패턴의 일치 여부 (true, false)
					
			.exec(패턴을 체크할 문자열)
					- 패턴에 일치하는 문자열을 추출
	
	/문자열/ -> 문자열이 포함되는 패턴
	
	[abc] -> 문자 클래스 -> a,b,c 문자 각각 중에 한개 
	[0-9] -> - 범위 (0123456789) -> 숫자인 것
				\d -> [0-9] 동일 -> 숫자인 패턴 
				\D -> [^0-9] 동일 -> 숫자가 아닌 패턴
						 
	[a-z] -> abcdef .... z
	[A-Z] -> ABCDEFG .... Z
	[^a-z] -> a~z가 아닌 문자 ^ -> 부정(반대)
	
			예) 입력 받은 데이터가 반드시 숫자인 경우
				-> 숫자가 아닌 문자가 있는지
				[^0-9] -> 숫자가 아닌 문자가 포함되어 있으면 true	
				  -> true 검증 실패
	
	
	문자 클래스[]외부에서 ^ -> 시작하는 문자
	
	숫자
		\d --> [0-9]  -> 숫자인 문자
		\D --> [^0-9] -> 숫자가 아닌 문자
	
	공백
		\s -> 공백 1개
		\S -> 공백이 아닌 문자 1개
		
	단어(알파벳, 숫자, 언더스코어(_))
		\w  -->단어 패턴[a-zA-Z0-9_]
		\W -->단어 패턴이 아닌 문자
		
		
	.  -> 문자 1개(줄바꿈 문자(\n)를 제외한)
	
	
	패턴의 반복 범위
	x{2,4} -> x가 2이상 4 이하 반복  ,  x가 2개, 3개, 4개 
	x{2} -> x가 2번 반복
	x{2,} -> x가 2번 이상 반복 
	x{,4} -> x가 4 이하 반복
	x?  -> x{0,1} -> 0이상 1이하 -> x가 있어도 되고 없어도 되는 패턴
	x+  -> x{1,} -> 1이상 반복 -> 반드시 1개는 있어야 된다
	x*   -> x{0,} -> 0이상 반복 -> 없어도 되고, 있어도 된다, 여러번 반복해도 된다
	
	
	참고)  패턴에서 사용되는 특수문자를 문자패턴으로 사용할 경우 역슬래시(\)
			예) [ ] -> 문자클래스
				\[abc\]
				\?
				\*
				\/
	
	
	/^단어/ -> 단어로 시작하는 패턴
	/단어$/ -> 단어로 끝나는 패턴
	
	| -> OR 여러개 중 하나의 패턴에 일치하는 지 
	/단어1|단어2|단어3/ -> 단어1, 단어2, 단어3 중에 하나
	
	(패턴) -> 서브패턴
			-> 1) 특정 패턴을 분리하여 문자열 치환
					replace
					예)
					const birthDay = "1990년 10월 3일"; // 1990/10/3
					const pattern = /([\d]{4})\D+([\d]{1,2})\D+([\d]{1,2})/
					const data = pattern.exec(birthDay);
					const newBirthDay = data[0].replace(pattern, "$1/$2/$3");
					
					예) 전화번호 변경 예시
					const mobile = "010/3481/2101"; // 010-3481-2101 - 정규표현식, 서브패턴()
					const pattern = /(01[016789])\/([\d]{3,4})\/([\d]{4})/
					const newMobile = mobile.replace(pattern, "$1-$2-$3");
					
					
					함수 
					function mobileFormat(mobile) {
						/**
							1. mobile 번호를 숫자로 전부 변경
								-> 숫자가 아닌 문자를 제거하면 -> 숫자만 남는다

							2. 숫자를 지정된 형식으로 변환
						*/
						mobile = mobile.replace(/[\D]/g, '');
						
					   
						let pattern = /(\d{3})(\d{4})(\d{4})/;
						if (mobile.length == 10) { // 구 휴대전화번호 
							pattern = /(\d{3})(\d{3})(\d{4})/;
						}
					   
						mobile = mobile.replace(pattern, "$1-$2-$3");

						return mobile;
					}
					
			-> 2) 특정 패턴의 문자열만 별도로 추출(이미지에서 src 속성에 있는 경로만 가져올때)
				   2-1) 네이버 메인페이지 -> 이미지의 경로
				   <img src="경로">
				   
				   <img src='경로'>
				   <img src=경로>
				   <IMG SRC=.. >
				   <img class='...' id='...' src=''>
				    <img class='...' id='...' src='' width='...' alt='...'>
					
					/<img\s+\S*src=["']?([^"'>]+)["']?[^>]*>/igm
					
	플래그
		/패턴/플래그
		i - case-insensitive -> 대소문자 구분 없이 체크 [a-zA-Z] --> /[a-z]/i 
		g - global -> 전역 체크
				str.replace(/little/g, "big");
		m - 여러줄 모드로 검색
		